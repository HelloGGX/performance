# 浏览器对javascript的解析策略

我们知道很多针对web优化的方案，只需要根据情况选择合适的方案实施即可，但方案背后的原理是什么？浏览器V8引擎在背后为提高javascript的速度做了哪些工作？以及作为Web开发人员如何将这些知识转化为收益？

下面我们说的javascript引擎都指V8引擎，主要用于 Google Chrome 浏览器和 Node.js 运行时。V8 是一个高性能的引擎，采用了多种优化技术，例如即时编译（JIT）、隐藏类和内联缓存（Inline Caches）等。

## JavaScript 引擎的工作流程

当浏览器或 Node.js 环境下载并加载 JavaScript 代码后，JavaScript 引擎会开始以下步骤：

1. **解析（Parsing）**
   - 词法分析（Lexical Analysis）：将源代码转换成一系列的标记（Tokens）。
   - 语法分析（Syntax Analysis）：将标记转换成抽象语法树（AST）。

2. **编译（Compilation）**
   - 字节码生成（Bytecode Generation）：Ignition 解释器将 AST 转换成字节码。
   - 优化编译（Optimized Compilation）：在代码执行过程中，根据代码的运行情况，V8 引擎会监视代码的执行情况，并识别出哪些代码片段被频繁执行。这些热点代码（hot code）会被送到优化编译器（如 Turbofan）进行进一步优化。进一步将热代码（Hot Code）优化为高效的机器代码。

3. **执行（Execution）**
    - 字节码解释（Bytecode Interpretation）：直接解释执行字节码。
    - 机器代码执行（Machine Code Execution）：执行编译后的机器代码。

4. **内存管理（Memory Management）**
    - 垃圾回收（Garbage Collection）：定期清理不再使用的对象，释放内存。

而在上面的解析阶段，更进一步的说在语法分析阶段，Javascript解释器使用两种策略来构建AST：

### 预解析（pre-parsing）
在代码初次加载时，V8引擎会先进行一种轻量级的预解析，只检查基本的语法结构是否正确，但不会生成完整的AST。这种方式主要是为了快速通过初步的语法检查，减少初始加载时间

- 快速扫描：预解析器快速扫描代码，以标记函数和变量声明，但不会深入解析函数体。
- 跳过函数体：对于函数体，预解析器会记录它们的位置和大小，但不会立即解析它们的内容。
- 语法检查：预解析器会进行基本的语法检查，但不会检查函数体内部的详细语法。
  
预解析的策略是，解析器在遇到函数声明时，不立即解析整个函数的内容，而是先标记一下有这个函数。当这个函数真的被调用时，再去解析它的具体内容。这样做可以避免在程序执行过程中解析未被调用的函数，从而节省资源，提高性能。预解析不仅适用于函数，还适用于循环、条件判断、对象等。基本上，所有需要解析的代码块都可以使用这种方法。

例子：

```js
// 这个函数会被标记为 lazy parsing
function calculateLargeData() {
  let data = [];
  for (let i = 0; i < 1000000; i++) {
    data.push(i * i);
  }
  return data;
}
// 顶级代码调用
console.log(calculateLargeData()); // 这行代码会触发 lazy parsing 对 calculateLargeData 的解析
```

### 完整解析 (full-Parsing)

完整解析是在预解析之后进行的，通常在代码即将执行或函数被调用时进行。完整解析的主要特点和步骤如下：

- 详细解析：完整解析器（Full Parser）会深入解析所有代码，包括函数体和嵌套的代码块。
- 生成 AST：完整解析器会生成详细的抽象语法树（AST），用于后续的编译和优化。
- 语法和语义检查：在完整解析过程中，V8 进行详细的语法和语义检查，确保代码的正确性。

完整解析处于**预解析之后，字节码生成之前**

假如我们需要指定v8引擎采用完整解析，那么写一个立即执行函数（IIFE）强制V8立即执行并解析函数体。这是因为自调用函数需要立即执行，因此引擎会对其进行完整解析。

```js
(function() {
  // 这个函数体会被立即解析和执行
  console.log('This is immediately invoked and thus fully parsed');
})();
```

我们会注意到以上两种策略，在实际应用场景中会有很多体现：
1. full-Parsing：提供即时的语法检查和优化机会，适用于小型脚本和关键代码路径；
2. lazy parsing 则通过延迟解析未使用的代码，提升初始加载性能和内存使用效率，适用于大型脚本和动态加载场景。

比如我们的路由的懒加载，相关的回调，只有在相应的路由变化时才会被解析和执行，这减少了初始加载的性能开销。
还有我们的动态导入（Dynamic Import）、React.lazy、分包优化、包括点击按钮时才加载对应js逻辑，都是基于v8引擎的两种策略而来的。








