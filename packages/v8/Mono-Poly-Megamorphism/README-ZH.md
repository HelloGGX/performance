# V8 引擎中的 Monomorphism, Polymorphism 和 Megamorphism

在现代 JavaScript 引擎中，性能优化是一个重要的研究方向。V8 引擎是 Google 开发的开源 JavaScript 引擎，用于 Chrome 浏览器和 Node.js。为了提升 JavaScript 的执行效率，V8 使用即时编译（JIT）技术，将 JavaScript 代码编译为高效的机器码。JIT 编译器在运行时根据代码的实际执行情况进行动态优化，利用内联缓存（Inline Cache, IC）、多态内联缓存（Polymorphic Inline Cache, PIC）等机制，处理不同的函数调用模式。根据 Monomorphism（单态性）、Polymorphism（多态性）和 Megamorphism（巨态性）三种情况，JIT 编译器分别生成高度优化的代码。下面分别介绍这三种情况：

## Monomorphism
Monomorphism（单态性）指的是函数在被调用时，它的参数和返回值类型始终保持一致。在 JavaScript 中，这意味着函数每次调用时都使用相同的对象结构（shape）和相同的属性类型。

### 实现与作用
- 优化性能：当函数表现出单态性时，JIT 编译器可以生成高度优化的机器码，因为它可以假设每次调用时参数和返回值的类型都相同。
- 内联缓存：JIT 编译器利用内联缓存（Inline Cache, IC）来记录和优化这些单态调用，减少类型检查和属性查找的开销。
- 代码优化：由于函数总是处理相同类型的参数，JIT 编译器可以进行内联展开和其他特定优化

例如，考虑下面的代码片段：

```javascript
function add(a, b) {
    return a.x + b.y;
}

let obj1 = { x: 1, y: 2 };
let obj2 = { x: 3, y: 4 };

add(obj1, obj2); // 第一次调用
add(obj1, obj2); // 第二次调用
```

在第一次调用 `add` 函数时，V8 会记录 `obj1` 和 `obj2` 的类型，并创建一个内联缓存。如果第二次调用时传入的对象类型与第一次相同，V8 直接使用缓存，大大提高了执行效率。

## Polymorphism
Polymorphism（多态性）指的是函数在被调用时，可以处理不同类型的参数。这在 JavaScript 中非常常见，因为 JavaScript 是动态类型语言。

### 实现与作用

- 多态内联缓存：JIT 编译器使用多态内联缓存（Polymorphic Inline Cache, PIC）来处理多态函数调用，记录多种不同类型的对象及其操作结果。
- 代码生成：对于多态函数，JIT 编译器需要生成更通用的机器码，同时利用缓存来优化常见类型的调用。
- 分支预测：JIT 编译器可以使用分支预测来处理多态调用，尽量减少类型检查的开销。

考虑下面的例子：

```javascript
function add(a, b) {
    return a.x + b.y;
}

let obj1 = { x: 1, y: 2 };
let obj2 = { x: 3, y: 4 };
let obj3 = { x: "5", y: 6 }; // x 属性是字符串类型

add(obj1, obj2); // 第一次调用
add(obj3, obj2); // 第二次调用，不同类型的对象
```

在这种情况下，V8 会创建一个多态内联缓存来记录 `obj1` 和 `obj3` 的类型。这样，当 `add` 函数被不同类型的对象调用时，V8 可以有效地处理多态性。

## Megamorphism
Megamorphism（巨态性）指的是函数在被调用时，处理了非常多种不同类型的参数。当一个函数的调用多态性超过一定数量（通常是 4 或 5 种类型）时，V8 会将其视为巨态函数。



### 实现与作用

- 缓存失效：当函数变成巨态时，内联缓存的效率降低，因为缓存需要处理的类型过多。
- 通用优化：JIT 编译器会切换到更通用的优化策略，例如字节码解释器或更通用的 JIT 编译器。这些策略虽然比内联缓存稍慢，但在处理巨态函数时更加高效。
- 动态编译：JIT 编译器可以动态生成和调整机器码，以适应多种类型的参数调用，尽量保持执行效率。

例如：
```javascript
function add(a, b) {
    return a.x + b.y;
}

let obj1 = { x: 1, y: 2 };         // 类型 1
let obj2 = { x: 3, y: 4 };         // 类型 2
let obj3 = { x: "5", y: 6 };       // 类型 3
let obj4 = { a: 7, b: 8 };         // 类型 4
let obj5 = { x: true, y: 10 };     // 类型 5
let obj6 = { x: 1, y: 2, z: 3 };   // 类型 6

add(obj1, obj2);  // 调用 1
add(obj3, obj2);  // 调用 2
add(obj4, obj2);  // 调用 3
add(obj5, obj2);  // 调用 4
add(obj6, obj2);  // 调用 5
```

在这个例子中，`add` 函数处理了 5 种不同类型的对象：

1. `obj1` 和 `obj2` 类型相同（`{ x: number, y: number }`）
2. `obj3` 类型不同（`{ x: string, y: number }`）
3. `obj4` 类型不同（`{ a: number, b: number }`）
4. `obj5` 类型不同（`{ x: boolean, y: number }`）
5. `obj6` 类型不同（`{ x: number, y: number, z: number }`）

这样就达到了 Megamorphism 的标准，即函数需要处理多种不同的对象类型，从而触发 V8 的巨态性优化策略。



## 浏览器是如何识别不同类型的？
JavaScript 对象在底层由引擎以一种称为“形状（shape）”或“隐藏类（hidden class）”的结构来表示。每个对象都有一个形状，它描述了对象的属性及其在内存中的布局。

- **对象形状**：是对一个对象的结构的描述，包括对象的属性名及其顺序。这种形状帮助引擎优化对象属性的查找和访问。
- **隐藏类**：是V8引擎中对对象形状的具体实现。每个对象在第一次创建时会被分配一个隐藏类，随着对象属性的添加和删除，这个隐藏类会动态改变。

对象形状的创建和演变：
- 当创建一个空对象时，V8会为其分配一个初始的隐藏类（通常称为“空类”）。
- 当给对象添加一个新属性时，V8会创建一个新的隐藏类，记录对象的新形状。例如：

```javascript
let obj = {};
obj.a = 10; // 创建了一个新的隐藏类，记录包含属性'a'的形状
obj.b = 20; // 创建另一个新的隐藏类，记录包含属性'a'和'b'的形状
```

共享隐藏类：
- 如果两个对象具有相同的属性和顺序，它们可以共享同一个隐藏类，从而减少内存开销和提高查找效率。例如：

```javascript
let obj1 = { a: 1, b: 2 };
let obj2 = { a: 3, b: 4 };
// obj1和obj2共享同一个隐藏类，因为它们具有相同的属性和顺序
```

### 类型标记与动态检查

#### 类型标记（Type Tagging）

V8 使用类型标记来跟踪变量的类型。类型标记可以是直接嵌入到值中的元数据，也可以是关联在值外部的附加信息。V8 使用以下几种主要类型：

- `Smi`（Small Integer）：用于表示小整数。
- `Heap Number`：用于表示大整数和浮点数。
- `String`：用于表示字符串。
- `Boolean`：用于表示布尔值。
- `Object`：用于表示对象。
- `Undefined` 和 `Null`：用于表示未定义和空值。

#### 动态类型检查
由于 JavaScript 是动态类型语言，变量类型可以在运行时改变。V8 通过动态类型检查来处理这种情况。例如：

```javascript
let a = 42;       // a 是 Smi 类型
a = "hello";      // a 变为 String 类型
a = true;         // a 变为 Boolean 类型
```

在每次赋值时，V8 都会检查并更新变量的类型标记。

## 即时编译（JIT）技术的其他优化：
### 1. 函数内联（Function Inlining）

V8 可以将常调用的小函数内联到调用点，消除函数调用的开销，并进行跨函数优化。例如：
```javascript
function square(x) {
    return x * x;
}

function sumOfSquares(a, b) {
    return square(a) + square(b);
}
```

在这种情况下，V8 可能会将 `square` 函数内联到 `sumOfSquares` 函数中，从而减少调用开销并优化性能。
### 2. 类型特化（Type Specialization）
V8 可以根据函数参数的类型生成特化代码。生成特化代码可以避免通用代码中对类型进行多次检查和处理，从而提高执行效率。例如，对于固定类型的数值运算，可以直接生成相应的机器码，而不需要动态检查类型。
```js
function processNumber(num) {
    return num * 2;
}

function processData(data) {
    if (typeof data === 'number') {
        return processNumber(data);
    }
    // 处理其他类型的数据
}
```
## 优化建议

V8 引擎通过内联缓存、类型标记、多态和巨态优化、JIT 编译等多种技术，来高效地识别和处理不同类型的数据。这些技术使得 JavaScript 能够在现代浏览器和服务器环境中高速运行，提供流畅的用户体验和高性能的服务器响应。以下是一些优化建议：

1. **尽量保持单态性**：尽量让函数在每次调用时使用相同类型的参数和对象结构。
2. **避免不必要的多态性**：尽量避免让函数处理多种不同类型的参数。如果确实需要处理不同类型的数据，可以将多态性封装在较小的函数中。
3. **避免巨态性**：避免让单个函数处理过多种类的参数类型。如果一个函数必须处理多种类型，考虑将其拆分为多个较小的函数。
4. **使用一致的对象结构**：确保同一类对象在代码中具有一致的结构和属性顺序。
5. **避免频繁更改对象结构**：尽量避免在对象创建后频繁添加或删除属性。
6. **利用类型特化**：在性能关键的代码路径中，尽量避免处理不同类型的数据。
7. **小函数内联**：将小函数内联到调用点，减少函数调用的开销。